# ADR-003: Dynamic Content Type Storage Strategy

**Status:** Proposed  
**Date:** 2026-01-27
**Author:** Fedor Terekhov (FterDev)

## Context

Hopen's core differentiator is runtime schema definition - the ability to create 
and modify content types without code changes, rebuilds, or deployments. This 
requires a database storage strategy that balances flexibility with performance 
and maintainability.

**The Challenge:**

Traditional CMS solutions require developers to define content schemas in code 
(e.g., Strapi models, Contentful content types via API). When a user wants a 
new content type, they must:
1. Define the schema in code
2. Create/run migrations
3. Rebuild and redeploy the application

Hopen eliminates this by allowing users to define content types dynamically 
through the Admin UI or API. However, this creates a fundamental database 
design challenge: how do we store content items with varying, user-defined 
structures?

**Key Requirements:**

- Support dynamic content type definition at runtime via API/UI
- Store content items based on user-defined schemas
- Validate content against its content type schema
- Query and filter content efficiently (e.g., "get all blog posts where status=published")
- Support common field types: text, number, boolean, date, rich text, references
- Handle 100k+ content items with acceptable performance
- Enable future features: content relationships, localization, versioning

**Questions to Answer:**

1. How do we store content type definitions (schemas)?
2. How do we store content items with varying structures?
3. How do we validate content against schemas?
4. How do we query content efficiently despite dynamic schemas?
5. How do we handle schema evolution (adding/removing fields)?
6. What PostgreSQL-specific features should we leverage?
  

## Decision

We will use **Option 3: Hybrid Approach with Enhanced Content Metadata**.

Content type schemas are stored as JSONB in the ContentTypes table, while 
content items use a combination of relational columns for system metadata 
and JSONB for user-defined content data.

**Database Schema:**
```sql
ContentTypes {
  id: uuid PRIMARY KEY
  name: varchar(100) UNIQUE NOT NULL
  display_name: varchar(200) NOT NULL
  description: text
  schema: jsonb NOT NULL  -- JSON Schema definition
  is_active: boolean DEFAULT true
  created_at: timestamp NOT NULL DEFAULT now()
  updated_at: timestamp NOT NULL DEFAULT now()
}

Content {
  id: uuid PRIMARY KEY
  content_type_id: uuid NOT NULL REFERENCES ContentTypes(id)
  
  -- System metadata (relational columns)
  slug: varchar(200) UNIQUE
  status: varchar(20) NOT NULL DEFAULT 'draft'
  
  -- User content (JSONB)
  data: jsonb NOT NULL
  
  -- Audit trail
  created_at: timestamp NOT NULL DEFAULT now()
  updated_at: timestamp NOT NULL DEFAULT now()
  published_at: timestamp
  
  -- Future features (nullable, activated later)
  created_by: uuid
  updated_by: uuid
  locale: varchar(10)
  version: integer DEFAULT 1
}

-- Indexes
CREATE INDEX idx_content_type ON Content(content_type_id);
CREATE INDEX idx_content_status ON Content(status);
CREATE INDEX idx_content_slug ON Content(slug) WHERE slug IS NOT NULL;
CREATE INDEX idx_content_published ON Content(published_at) 
  WHERE status = 'published';
CREATE INDEX idx_content_data_gin ON Content USING GIN (data);
```


## Options Considered

### Option 1: Pure Meta-Model with Relational Fields

**Description:**
Store content type definitions and their fields as separate relational tables. 
Content items stored with JSONB data column.

**Structure:**
```sql
ContentTypes {
  id: uuid
  name: varchar (unique)
  display_name: varchar
  description: text
  created_at: timestamp
  updated_at: timestamp
}

ContentTypeFields {
  id: uuid
  content_type_id: uuid (FK)
  name: varchar
  field_type: varchar  -- text, number, boolean, date, richtext
  required: boolean
  default_value: jsonb
  validation_rules: jsonb
  order: integer
}

Content {
  id: uuid
  content_type_id: uuid (FK)
  data: jsonb  -- actual content data
  created_at: timestamp
  updated_at: timestamp
}
```

**Pros:**
- Strongly typed field definitions at database level
- Easy to query "all text fields across all content types"
- Clear separation between schema and data
- Field metadata easily queryable (e.g., "show me all required fields")
- Familiar relational design pattern
- Can add field-level constraints and indexes

**Cons:**
- Two tables to maintain for content type definition
- Redundant schema information (fields in table + used in JSONB validation)
- More complex queries to reconstruct full content type schema
- Additional JOINs when fetching content type with fields
- Schema changes require updates to ContentTypeFields table
- Overhead for simple content types with few fields

---

### Option 2: Pure JSONB Schema Storage

**Description:**
Store complete content type schema as JSONB. Minimal relational structure.
All schema information in JSON format.

**Structure:**
```sql
ContentTypes {
  id: uuid
  name: varchar (unique)
  display_name: varchar
  description: text
  schema: jsonb  -- complete JSON Schema definition
  created_at: timestamp
  updated_at: timestamp
}

Content {
  id: uuid
  content_type_id: uuid (FK)
  data: jsonb  -- actual content data
  created_at: timestamp
  updated_at: timestamp
}
```

**Example schema JSONB:**
```json
{
  "fields": [
    {
      "name": "title",
      "type": "text",
      "required": true,
      "maxLength": 200
    },
    {
      "name": "published",
      "type": "boolean",
      "default": false
    }
  ]
}
```

**Pros:**
- Simple data model - only two main tables
- Schema stored in single location (no synchronization needed)
- Flexible - can store any JSON Schema features
- Easy to version schemas (store history as JSONB)
- Fast content type fetching (one query, no JOINs)
- Schema modifications are simple JSONB updates
- Leverages PostgreSQL JSONB strengths

**Cons:**
- Cannot query field metadata easily (e.g., "find all required fields")
- No database-level constraints on schema structure
- Application must parse JSONB to understand schema
- Harder to generate field-level reports or analytics
- No referential integrity for field definitions
- Requires JSON Schema knowledge to modify schemas

---

### Option 3: Hybrid Approach with Enhanced Content Metadata

**Description:**
Store content type schema as JSONB but include commonly queried metadata 
as relational columns on the Content table. Optimizes for both flexibility 
and query performance.

**Structure:**
```sql
ContentTypes {
  id: uuid
  name: varchar (unique)
  display_name: varchar
  description: text
  schema: jsonb  -- complete JSON Schema definition
  created_at: timestamp
  updated_at: timestamp
}

Content {
  id: uuid
  content_type_id: uuid (FK)
  slug: varchar (unique, nullable)  -- for SEO-friendly URLs
  status: varchar  -- draft, published, archived
  data: jsonb  -- actual content data
  created_by: uuid (nullable, FK to Users - future)
  updated_by: uuid (nullable, FK to Users - future)
  created_at: timestamp
  updated_at: timestamp
  published_at: timestamp (nullable)
}

-- Indexes
CREATE INDEX idx_content_status ON Content(status);
CREATE INDEX idx_content_published_at ON Content(published_at) 
  WHERE status = 'published';
CREATE INDEX idx_content_data_gin ON Content USING GIN (data);
```

**Optional: Generated columns for frequently queried fields**
```sql
-- Can be added later for performance
ALTER TABLE Content ADD COLUMN title_generated TEXT
  GENERATED ALWAYS AS (data->>'title') STORED;
```

**Pros:**
- Best of both worlds - flexibility + performance
- Fast filtering on common fields (status, dates)
- SEO-friendly slug support at database level
- Simple content type schema (JSONB)
- Can add generated columns later for optimization
- Metadata fields are strongly typed
- Supports future features (user tracking, workflows)

**Cons:**
- More columns to maintain
- Need to decide which fields are "important enough" for columns
- Partial redundancy (status might also be in data JSONB)
- Requires discipline to keep metadata in sync
- Migration path less clear if requirements change
- Slightly more complex than pure JSONB approach

---

## Rationale

**Balance between flexibility and performance:**
The hybrid approach provides runtime schema flexibility while maintaining 
query performance for common operations. System fields (status, timestamps, 
slug) are queried frequently and benefit from relational columns, while 
user-defined content remains completely flexible in JSONB.

**Clear separation of concerns:**
System metadata (managed by Hopen) is distinct from user content (defined by 
content types). This prevents conflicts where users might accidentally create 
fields named "status" or "id", and makes the API clearer: system fields are 
always top-level, content is nested in the data object.

**Future-proof design:**
By including nullable columns for anticipated features (user tracking, i18n, 
versioning), we minimize breaking schema changes. These features can be 
activated without migrations by simply making columns non-nullable and adding 
constraints.

**Proven pattern:**
This approach is used by successful headless CMS platforms (Strapi, Directus) 
and represents industry best practices. It's well-documented and understood 
by developers.

**PostgreSQL strengths:**
Leverages PostgreSQL's JSONB capabilities (GIN indexes, operators, functions) 
while maintaining relational benefits for structured data. We can add 
generated columns later for frequently queried JSONB fields without schema 
rewrites.

**Validation strategy:**
Content type schemas stored as JSONB can be used directly with JSON Schema 
validation libraries (NJsonSchema for .NET). Application-layer validation 
provides flexibility while PostgreSQL constraints ensure basic data integrity.

---

## Consequences

### Positive

- Fast queries on system fields (status, dates) via indexes on columns
- Complete flexibility for user-defined content structures via JSONB
- No database migrations needed when users create new content types
- Clear API structure: system metadata + nested user content
- Can optimize specific JSONB fields with generated columns later
- User tracking, i18n, and versioning prepared without schema changes
- JSON Schema validation provides type safety at application level
- Content type schemas are simple to version and modify
- Supports future features: relationships, workflows, multi-tenancy

### Negative

- More columns to maintain than pure JSONB approach
- Requires discipline: must prevent system field names in user content
- Nullable future columns add slight complexity to initial schema
- Generated columns must be added manually if performance optimization needed
- Application layer responsible for validation (not database constraints)
- Schema evolution requires careful handling of existing content
- Documentation needed for "system vs user" field distinction

### Neutral

- Migration strategy accepts that some schema changes are inevitable
- Performance optimization (generated columns) can be added incrementally
- Content type schema format may evolve (currently JSON Schema)
- Future features (versioning, i18n) will require activation migrations
- Trade-off: initial complexity for long-term maintainability

---

## Implementation Notes

**Phase 1: Core Implementation**

1. Create entities with Entity Framework Core:
```csharp
public class ContentType
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string DisplayName { get; set; }
    public string? Description { get; set; }
    public JsonDocument Schema { get; set; }  // EF Core 5+ JSONB support
    public bool IsActive { get; set; } = true;
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

public class Content
{
    public Guid Id { get; set; }
    public Guid ContentTypeId { get; set; }
    public ContentType ContentType { get; set; }
    
    public string? Slug { get; set; }
    public string Status { get; set; } = "draft";
    public JsonDocument Data { get; set; }
    
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public DateTime? PublishedAt { get; set; }
    
    // Future features
    public Guid? CreatedBy { get; set; }
    public Guid? UpdatedBy { get; set; }
    public string? Locale { get; set; }
    public int Version { get; set; } = 1;
}
```

2. Configure EF Core for PostgreSQL JSONB:
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity(entity =>
    {
        entity.Property(e => e.Schema)
            .HasColumnType("jsonb")
            .IsRequired();
            
        entity.HasIndex(e => e.Name).IsUnique();
    });
    
    modelBuilder.Entity(entity =>
    {
        entity.Property(e => e.Data)
            .HasColumnType("jsonb")
            .IsRequired();
            
        entity.Property(e => e.Status)
            .HasMaxLength(20)
            .HasDefaultValue("draft");
            
        entity.HasIndex(e => e.Slug).IsUnique();
        entity.HasIndex(e => e.Status);
        entity.HasIndex(e => e.ContentTypeId);
    });
}
```

3. Implement JSON Schema validation:
```csharp
public class ContentValidator
{
    public async Task ValidateAsync(
        Content content, 
        ContentType contentType)
    {
        var schema = await JsonSchema.FromJsonAsync(
            contentType.Schema.RootElement.GetRawText());
        
        var jsonContent = content.Data.RootElement.GetRawText();
        var errors = schema.Validate(jsonContent);
        
        return new ValidationResult 
        { 
            IsValid = errors.Count == 0,
            Errors = errors
        };
    }
}
```

4. API layer prevents system field conflicts:
```csharp
public class ContentService
{
    private static readonly string[] ReservedFields = 
        { "id", "status", "slug", "createdAt", "updatedAt" };
    
    public async Task CreateAsync(ContentCreateDto dto)
    {
        // Ensure data doesn't contain reserved fields
        var data = dto.Data;
        foreach (var field in ReservedFields)
        {
            if (data.RootElement.TryGetProperty(field, out _))
                throw new ValidationException(
                    $"Field '{field}' is reserved and cannot be used in content data");
        }
        
        var content = new Content
        {
            ContentTypeId = dto.ContentTypeId,
            Status = dto.Status ?? "draft",
            Slug = dto.Slug,
            Data = data
        };
        
        await _validator.ValidateAsync(content, contentType);
        return await _repository.CreateAsync(content);
    }
}
```

**Phase 2: Optimization (when needed)**

Add generated columns for frequently queried JSONB fields:
```sql
-- Example: if "title" is frequently searched
ALTER TABLE Content 
ADD COLUMN title_generated TEXT 
  GENERATED ALWAYS AS (data->>'title') STORED;

CREATE INDEX idx_content_title ON Content(title_generated);
```

**Phase 3: Future Feature Activation**

When user authentication is ready:
```sql
-- Make user tracking mandatory for new content
ALTER TABLE Content 
  ALTER COLUMN created_by SET NOT NULL;
  
-- Backfill existing content with system user
UPDATE Content 
SET created_by = 'system-user-uuid' 
WHERE created_by IS NULL;
```

**Testing Strategy:**
- Unit tests for JSON Schema validation with various field types
- Integration tests with PostgreSQL for CRUD operations
- Performance tests with 100k+ content items
- Test JSONB queries with GIN indexes
- Test constraint violations (unique slug, required fields)

---

## References

- [PostgreSQL JSONB Documentation](https://www.postgresql.org/docs/current/datatype-json.html)
- [JSON Schema Specification](https://json-schema.org/)
- [NJsonSchema Library](https://github.com/RicoSuter/NJsonSchema)
- [EF Core PostgreSQL JSONB](https://www.npgsql.org/efcore/mapping/json.html)
- [Strapi Data Model Architecture](https://docs.strapi.io/dev-docs/backend-customization/models)
- [Contentful Content Model Design](https://www.contentful.com/developers/docs/concepts/data-model/)
- [PostgreSQL GIN Indexes](https://www.postgresql.org/docs/current/gin-intro.html)
- [Generated Columns in PostgreSQL](https://www.postgresql.org/docs/current/ddl-generated-columns.html)
