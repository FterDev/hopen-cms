# ADR-001: Overall Architecture Pattern

**Status:** Accepted  
**Date:** 2026-01-25
**Author:** Fedor Terekhov (FterDev)

## Context

Hopen is a headless CMS designed for runtime schema definition and self-hosting. 
As the codebase grows from MVP to a feature-rich application, we need an 
architectural pattern that provides structure without hindering development speed.

**The Problem:**

Without a clear architecture, code organization deteriorates:
- Business logic scatters across controllers, services, and repositories
- Contributors struggle to locate where functionality belongs
- Testing becomes difficult without clear boundaries
- Spaghetti code emerges as features intertwine
- Refactoring becomes risky and time-consuming

**Project Constraints:**

**Solo start with open source future:**
The project begins as a solo endeavor but is designed for contributors. The 
architecture must be approachable for new developers while providing enough 
structure to prevent chaos.

**Speed matters:**
MVP needs to ship quickly. Over-engineering upfront would delay delivery. The 
architecture should enable rapid development in early stages while supporting 
future complexity.

**Testing is essential:**
As an open source project, automated tests are critical for confident 
refactoring and reviewing contributions. The architecture must facilitate 
testing without excessive mocking complexity.

**Collaboration structure:**
Clear separation of concerns prevents contributors from stepping on each other's 
toes. Well-defined boundaries enable parallel development and reduce merge conflicts.

**Key Questions to Answer:**

1. How do we organize code to prevent spaghetti?
2. How do we balance structure with development speed?
3. How do we make the codebase approachable for contributors?
4. How do we ensure testability without excessive boilerplate?
5. How do we enable future evolution (scaling, microservices, CQRS)?

---

## Decision

We will use a **Pragmatic Hybrid Architecture** inspired by Clean Architecture 
principles but optimized for development speed and contributor friendliness.

**Project Structure:**

```
Hopen.Core/                         # DOMAIN LAYER
  Entities/
    ContentType.cs
    Content.cs
    User.cs
  Interfaces/
    Repositories/
      IContentTypeRepository.cs
      IContentRepository.cs

Hopen.Application/                  # APPLICATION LAYER
  Interfaces/
    Services/
      IContentTypeService.cs
      IContentService.cs
      
  Features/                         # Feature-based organization
    ContentTypes/
      Services/
        ContentTypeService.cs
      DTOs/
        ContentTypeDto.cs
        CreateContentTypeDto.cs
      Validators/
        CreateContentTypeValidator.cs
    Content/
      Services/
      DTOs/
      Validators/

Hopen.Infrastructure/               # INFRASTRUCTURE LAYER
  Data/
    HopenDbContext.cs
    Repositories/
      ContentTypeRepository.cs
  External/
    EmailService.cs

Hopen.Api/                          # PRESENTATION LAYER
  Controllers/
    ContentTypesController.cs
    ContentController.cs
  Middleware/
  Configuration/
```

**Dependency Rules:**

```
Core (Domain)
  └─ Entities + Repository Interfaces
  └─ Zero external dependencies

Application
  └─ depends on Core
  └─ Service Interfaces + Implementations
  └─ DTOs, Validators
  └─ Feature-based organization

Infrastructure
  └─ depends on Core (implements Repository Interfaces)
  └─ depends on Application (for service dependencies if needed)
  
Api
  └─ depends on Application (uses Service Interfaces)
  └─ depends on Infrastructure (for DI registration)
```

**Layer Responsibilities:**

**Core (Domain):**
- Domain entities (ContentType, Content, User)
- Repository interface definitions
- Pure domain logic (no frameworks, no external dependencies)

**Application (Use Cases):**
- Service interfaces (IContentTypeService defines use cases)
- Service implementations (business logic orchestration)
- DTOs (data transfer objects for API contracts)
- Validators (business rule enforcement)
- Feature-based folders (ContentTypes, Content, Auth, Media)

**Infrastructure (External Concerns):**
- Repository implementations (EF Core, database access)
- External service integrations (email, file storage, etc.)
- Framework-specific implementations

**Api (Presentation):**
- Controllers (HTTP endpoints)
- Middleware (authentication, error handling, logging)
- Configuration (dependency injection, API versioning)

---

## Options Considered

### Option 1: Clean Architecture (Strict)

**Description:**
Pure Clean Architecture with strict dependency inversion. All abstractions in 
the domain core, implementations in outer layers. Use cases modeled as explicit 
command/query objects with dedicated handlers.

**Structure:**
```
Domain Core (Entities, Interfaces, Commands, Queries)
  ↑
Application (Command/Query Handlers)
  ↑
Infrastructure (Implementations)
  ↑
Presentation (API, UI)
```

**Pros:**
- Maximum testability through complete abstraction
- Framework independence at domain level
- Clear boundaries enforced by dependency rules
- Scales well to large, complex systems
- Supports advanced patterns (Domain Events, CQRS)

**Cons:**
- High initial complexity and boilerplate
- Command/Query objects for every operation
- Steep learning curve for contributors
- Slower initial development
- Can feel over-engineered for straightforward CRUD
- Requires strict discipline to maintain boundaries

---

### Option 2: CQRS (Command Query Responsibility Segregation)

**Description:**
Separate models and handlers for commands (writes) and queries (reads). 
Operations are explicit, routed through a mediator pattern (e.g., MediatR).

**Structure:**
```
Commands (CreateContentType, UpdateContent)
  ↓
Command Handlers
  ↓
Write Model

Queries (GetContentTypes, SearchContent)
  ↓
Query Handlers
  ↓
Read Model (can be different from write model)
```

**Pros:**
- Extremely scalable (read/write can scale independently)
- Clear operation boundaries (each use case is explicit)
- Performance optimization opportunities (separate read models)
- Testability (handlers are small, focused units)
- Supports event sourcing and complex workflows

**Cons:**
- Significant complexity overhead
- Handler for every single operation
- Mediator pattern adds indirection
- Debugging is more difficult
- Overkill for standard CRUD operations
- Eventual consistency challenges if using separate stores

---

### Option 3: Pragmatic Hybrid (CHOSEN)

**Description:**
Clean Architecture principles without dogmatic enforcement. Dependency inversion 
where it matters, pragmatic decisions elsewhere. Service-based instead of 
command/query-based. Feature folders for organization.

**Structure:**
```
Core: Entities + Repository Interfaces
Application: Service Interfaces + Implementations + DTOs (feature-based)
Infrastructure: Repository Implementations + External Services
Api: Controllers + Middleware
```

**Pros:**
- Balanced structure without excessive boilerplate
- Faster development than strict Clean Architecture
- Testable through service and repository interfaces
- Feature-based organization aids navigation
- Can evolve to stricter patterns (CQRS) later
- Approachable for contributors familiar with layered architectures
- Clear separation of concerns without over-abstraction

**Cons:**
- Not a "recognized pattern" (requires explanation)
- Easier to violate architectural boundaries than strict approaches
- Requires documentation of conventions
- Service interfaces in Application (not Core) - less "pure"
- Contributors need guidance on where code belongs

**Trade-offs:**
- Pragmatism over architectural purity
- Development speed over perfect abstraction
- Contributor friendliness over framework independence

---

## Rationale

**Structure for collaboration:**
Clear architectural boundaries prevent spaghetti code. Contributors immediately 
understand where to add new features (Application/Features), where entities live 
(Core/Entities), and how to integrate external systems (Infrastructure). This 
reduces onboarding time and merge conflicts.

**Business logic centralization:**
Application layer contains all business logic in feature-based folders. Services 
orchestrate use cases, validators enforce rules, DTOs define contracts. This 
centralization makes it easy to locate and modify business behavior without 
hunting through controllers or repositories.

**Testability through interfaces:**
Repository interfaces in Core and Service interfaces in Application enable unit 
testing without database dependencies. Controllers can be tested with mocked 
services. Services can be tested with mocked repositories. This facilitates 
test-driven development and confident refactoring.

**DTOs as business contracts:**
DTOs belong in Application because they represent application-level concerns: 
what data does the API need? How should validation work? DTOs are not domain 
concepts (Core) but use-case contracts (Application). This keeps Core focused 
on pure domain modeling.

**Evolution path to CQRS:**
The structure supports future migration to CQRS if needed:
- Services can be split into CommandHandlers and QueryHandlers
- DTOs can evolve to Commands and Queries
- Current structure maps naturally to CQRS patterns
This provides an escape hatch if complexity demands more sophisticated patterns.

**Why not strict Clean Architecture:**
Strict Clean requires Commands/Queries for every operation, significantly 
increasing boilerplate. For a CMS with straightforward CRUD operations, this 
overhead doesn't provide proportional value. We can adopt stricter patterns 
incrementally as specific features demand them.

**Why not CQRS upfront:**
CQRS is powerful but adds substantial complexity. Hopen's MVP doesn't have the 
scale or complexity to justify separate read/write models and mediator patterns. 
Starting with services is more pragmatic; CQRS can be introduced for specific 
high-complexity features later.

**Feature-based organization:**
Application/Features folders group related code (services, DTOs, validators) by 
feature rather than by technical layer. This improves cohesion: everything about 
ContentTypes lives together. It also supports potential extraction to microservices 
if Hopen scales beyond a monolith.

**The pragmatic trade-off:**
We sacrifice some architectural purity (service interfaces not in Core, DTOs in 
Application) for tangible benefits: faster development, easier onboarding, less 
boilerplate. This aligns with Hopen's goals: ship quickly, stay maintainable, 
welcome contributors.

---

## Consequences

### Positive

- **Business logic centralized:** All use cases, validation, and orchestration 
  live in Application layer, making behavior easy to locate and modify
- **Testability maintained:** Interfaces enable unit testing without external 
  dependencies (database, APIs, etc.)
- **Clear code organization:** Contributors immediately know where code belongs 
  (Core for domain, Application for use cases, Infrastructure for I/O)
- **Feature-based structure:** Related code grouped together improves cohesion 
  and supports future microservice extraction
- **DTOs in business layer:** DTOs represent application contracts and naturally 
  belong with use cases, not domain entities
- **Evolution to CQRS possible:** Current structure supports migration to command/query 
  patterns if complexity grows
- **Reduced boilerplate:** Avoids command/query objects for simple CRUD, 
  accelerating development
- **Contributor friendly:** Pattern is more approachable than strict Clean 
  Architecture or CQRS
- **Dependency inversion:** Core has no dependencies, enabling clean testing and 
  flexibility

### Negative

- **Requires clear rules:** Without strict enforcement, boundaries can be violated 
  (e.g., controllers bypassing services, infrastructure leaking into application)
- **Not a standard pattern:** "Pragmatic Hybrid" requires explanation and 
  documentation for contributors
- **Service interfaces not in Core:** Purists will note that use case abstractions 
  "should" live in domain layer
- **Potential inconsistency:** Developers may interpret "pragmatic" differently, 
  leading to architectural drift without code reviews
- **Documentation burden:** Conventions must be clearly documented (where do 
  interfaces go? when to use DTOs vs entities?)

### Neutral

- **Pragmatic approach traded for speed:** We accept less architectural purity 
  in exchange for faster initial development
- **Evolution expected:** Architecture will become stricter as project matures 
  and complexity increases
- **Feature folders may feel unconventional:** Some developers expect technical 
  layers (Services/, DTOs/) rather than feature folders
- **Testing strategy flexible:** Can use unit tests (mocked dependencies) or 
  integration tests (real dependencies) based on need

---

## Implementation Notes

**Project Setup:**

1. Create solution with 4 projects: Core, Application, Infrastructure, Api
2. Configure dependencies: Core ← Application ← Infrastructure ← Api
3. Establish folder structure in Application (Interfaces/, Features/)
4. Document conventions in CONTRIBUTING.md

**Dependency Injection Registration:**

Register services by layer in Api/Program.cs:
- Core: No registration (entities, interfaces only)
- Application: Register services (Scoped: IContentTypeService → ContentTypeService)
- Infrastructure: Register repositories, DbContext, external services

**Code Organization Rules:**

- Core: Only entities and repository interfaces, zero dependencies
- Application: Services implement use cases, DTOs define contracts, validators 
  enforce rules
- Infrastructure: Repositories implement Core interfaces using EF Core
- Api: Controllers use Application service interfaces, never directly access 
  repositories

**Testing Approach:**

- Unit test services with mocked repositories
- Unit test controllers with mocked services
- Integration test repositories with Testcontainers
- End-to-end test API with WebApplicationFactory

---

## References

- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [CQRS Pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs)
- [Feature Folders in ASP.NET](https://www.kamilgrzybek.com/blog/posts/simple-cqrs-implementation-raw-sql-ddd)
- [Pragmatic Clean Architecture](https://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html)