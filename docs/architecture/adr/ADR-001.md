# ADR-001: App Architecture
**Status:** Accepted  
**Date:** 2026-01-21
**Author:** Fedor Terekhov (FterDev)  

## Context

The current ADR handles the first point of the system architecture definition:

Overall Architecture Pattern

    Layered architecture (API → Business Logic → Data Access)
    Clean Architecture / Onion Architecture
    CQRS considerations
    Hybrid

It will define how the application should be splitted into different modules and is the base for future architecture diagrams and planning.

Important! UI is to be ignored at this point, as it's irrelevant for the main bussiness logic and system architecture.

## Decision



## Options Considered

### Classic Layered Architecture

**Description:**

Traditional three-layer architecture with clear horizontal separation between 
presentation, business logic, and data access. Each layer can only depend on 
the layer directly below it.

The app is separated into layers as following:

Presentation(API) -> Business Logic (Services) -> Data Access (Repositories) -> Database

It's the most common approach for small applications and leads very fast to a productive version and the planning by it self can be kept very simple. With the simplicity a side effect occurs. If the app stays in the simple version such an architeture is not a problem, but if the app grows and gets more features it's harder to keep the overview and with all the services and repositories it can very fast lead to spaghetti code. If the app grows and scalability becomes an important point it will be hard to extract some features to make those scaleable. Also it's easy to work at such projects as long as there are a few developers working on it or optimally one. With more people working on a such project more conflicts will occure.

**Pros:**
- Simplicity: Easy to understand and implement quickly
- Familiarity: Most developers know this pattern
- Fast initial development: Less boilerplate, get productive immediately
- Clear separation: Each layer has obvious responsibilities
- Tooling support: Works naturally with EF Core and ASP.NET patterns
- Easy onboarding: New contributors can start quickly

**Cons:**
- Tight coupling: Layers depend on concrete implementations below
- Testing challenges: Hard to test business logic without database
- Less flexible: Difficult to swap out data access layer
- Anemic domain: Business logic often scattered across services
- Layer violations: Easy to accidentally create dependencies across layers
- Scalability limits: Can become monolithic and hard to split

**Trade-offs:**
- Development speed vs. architectural purity
- Pragmatism vs. testability
- Immediate productivity vs. long-term flexibility

---

### Option 2: Clean Architecture / Onion

**Description:**

Dependency inversion-based architecture where the domain core is isolated 
from external concerns. Dependencies point inward toward the domain, never 
outward. External systems (database, APIs, UI) depend on the core, not 
vice versa.

**Structure:**
- **Domain Core**: Entities, value objects, domain interfaces (no dependencies)
- **Application Layer**: Use cases, business logic, application services
- **Infrastructure**: Database access, external APIs, file system
- **Presentation**: API controllers, middleware, configuration

**Pros:**
- Testability: Core business logic can be tested without external dependencies
- Maintainability: Clear separation of concerns, easy to locate code
- Flexibility: Easy to swap infrastructure (e.g., change database)
- Framework independence: Domain logic doesn't depend on .NET specifics
- Professional appearance: Demonstrates architectural maturity for contributors
- Scalability: Structure scales well as project grows

**Cons:**
- Boilerplate overhead: More files, interfaces, and mapping code
- Steeper learning curve: Contributors need to understand the pattern
- Slower initial development: More upfront setup required
- Can be overkill: For simple CRUD operations, adds unnecessary complexity
- Requires discipline: Easy to violate boundaries without strict reviews

**Trade-offs:**
- Code organization vs. development speed
- Testability vs. simplicity
- Long-term maintainability vs. short-term productivity
  
---

### Option 3: Command Query Responsibility Segregation 

**Description:**
Separates read operations (queries) from write operations (commands) into 
distinct models and handlers. Commands modify state, queries return data. 
Each operation has a dedicated handler, typically using the Mediator pattern.

**Structure:**
- **Commands**: CreateContentType, UpdateContent, DeleteContent
- **Command Handlers**: Execute business logic, validate, persist changes
- **Queries**: GetContentTypes, GetContentById, SearchContent
- **Query Handlers**: Optimize for read performance, return DTOs
- **Mediator**: Routes commands/queries to appropriate handlers (e.g., MediatR)

**Pros:**
- Performance optimization: Read and write models can be optimized independently
- Scalability: Easy to scale reads and writes separately
- Clarity: Each operation is explicit and isolated
- Testability: Handlers are small, focused, easy to test
- Flexibility: Can use different data stores for reads vs writes
- Extensibility: Easy to add new operations without modifying existing code

**Cons:**
- Complexity: More moving parts, more code to maintain
- Boilerplate: Handler for every single operation
- Learning curve: Contributors need to understand CQRS pattern
- Debugging difficulty: Request flow through mediator harder to trace
- Eventual consistency: If using separate read models, data may lag
- Overkill for simple CRUD: Adds overhead for straightforward operations

**Trade-offs:**
- Scalability and performance vs. complexity
- Explicit operations vs. development speed
- Future flexibility vs. immediate simplicity

### Option 4: Hybrid - Clean-ish Layered

**Description:**

Combines the simplicity of layered architecture with key Clean Architecture 
principles. Uses dependency inversion where it matters (interfaces in core, 
implementations in infrastructure) but avoids dogmatic separation. Prioritizes 
pragmatism over architectural purity.

**Structure:**
- **Hopen.Core**: Domain entities, interfaces, business logic, DTOs
- **Hopen.Infrastructure**: EF Core, repositories, external services
- **Hopen.Api**: Controllers, middleware, authentication, configuration
  
**Dependency Rules:**
- Core has zero external dependencies
- Infrastructure depends on Core (implements interfaces)
- Api depends on both Core and Infrastructure


**Pros:**
- Balanced approach: Structure without excessive boilerplate
- Faster development: Less ceremony than full Clean Architecture
- Easy to understand: Simpler mental model for contributors
- Testability: Core business logic can be tested in isolation
- Flexibility: Can evolve toward full Clean Architecture later
- Pragmatic: Use interfaces where valuable, skip where unnecessary
  
**Cons:**
- Less strict boundaries: Easier to violate architectural rules
- Requires discipline: No framework enforcement of conventions
- "Gray areas": Unclear where some code belongs without strict guidelines
- Documentation needed: Must clearly communicate conventions
- Inconsistency risk: Different developers may interpret rules differently
- Not a "recognized pattern": Harder to explain as "we use X architecture"

**Trade-offs:**
- Flexibility vs. strict architectural boundaries
- Pragmatism vs. pattern recognition
- Quick wins vs. long-term consistency

---

## Rationale

We chose the Pragmatic Layered with Clean Principles (Hybrid) approach, with a 
clear path toward full Clean Architecture as the project matures.

**Key deciding factors:**

**Immediate productivity while maintaining quality:**
The hybrid approach allows rapid MVP development without sacrificing long-term 
architectural health. We can ship features quickly while maintaining clear 
separation of concerns.

**Open source readiness:**
While starting as a solo project, Hopen is designed for contributors. The 
hybrid approach provides enough structure for contributors to understand where 
code belongs, without overwhelming them with full Clean Architecture complexity 
upfront.

**Evolutionary architecture:**
By starting with Core (domain) and Application (use cases) separated from day 
one, we establish the foundation for Clean Architecture. As business logic 
grows more complex, we can gradually enforce stricter boundaries without 
major refactoring.

**Project structure:**
```
Hopen.Core/          # Domain entities, value objects
Hopen.Application/   # Business logic, use cases, interfaces
Hopen.Infrastructure/ # EF Core, external services, implementations
Hopen.Api/           # Presentation layer
```

This separation maintains Clean Architecture's core principle (dependency 
inversion) while avoiding excessive boilerplate in early stages.

**Migration path:**
As the project grows in complexity or contributor count increases, we can 
incrementally adopt stricter Clean Architecture patterns (detailed use case 
handlers, CQRS for complex operations, domain events) without architectural 
rewrites.

## Consequences

### Positive
- Fast initial development while maintaining architectural quality
- Clear project structure guides contributors where to add code
- Core business logic testable without infrastructure dependencies
- Can evolve to full Clean Architecture without breaking changes
- Dependency inversion established from day one
- Professional appearance for portfolio and potential contributors
- Flexibility to make pragmatic decisions when strict patterns add no value


### Negative
- Requires active documentation of conventions and boundaries
- Risk of architectural drift without code review discipline
- Not a "standard" pattern - needs explanation in contributing guide
- Gray areas where code placement isn't immediately obvious
- Must resist temptation to violate boundaries for quick fixes
- Contributors may need guidance on when to use interfaces vs concrete types
  
### Neutral
- Architecture will evolve as project matures - documented in future ADRs
- Some operations may use simplified patterns while others follow strict Clean
- Team needs to accept that consistency will improve over time
- Code reviews must balance pragmatism with architectural principles

## Implementation Notes

[Optional - How to implement this decision] -> TBD

## References

https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs
https://mdamranhossain.substack.com/p/clean-architecture-vs-onion-architecture
https://www.geeksforgeeks.org/system-design/design-patterns-architecture/
https://www.geeksforgeeks.org/system-design/design-patterns-architecture/#cqrs-command-query-responsibility-segregation

