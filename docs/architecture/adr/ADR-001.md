# ADR-001: App Architecture
**Status:** Proposed  
**Date:** 2026-01-21
**Author:** Fedor Terekhov (FterDev)  

## Context

The current ADR handles the first point of the system architecture definition:

Overall Architecture Pattern

    Layered architecture (API → Business Logic → Data Access)
    Clean Architecture / Onion Architecture
    CQRS considerations
    Hybrid

It will define how the application should be splitted into different modules and is the base for future architecture diagrams and planning.

Important! UI is to be ignored at this point, as it's irrelevant for the main bussiness logic and system architecture.

## Decision



## Options Considered

### Classic Layered Architecture

**Description:**

Traditional three-layer architecture with clear horizontal separation between 
presentation, business logic, and data access. Each layer can only depend on 
the layer directly below it.

The app is separated into layers as following:

Presentation(API) -> Business Logic (Services) -> Data Access (Repositories) -> Database

It's the most common approach for small applications and leads very fast to a productive version and the planning by it self can be kept very simple. With the simplicity a side effect occurs. If the app stays in the simple version such an architeture is not a problem, but if the app grows and gets more features it's harder to keep the overview and with all the services and repositories it can very fast lead to spaghetti code. If the app grows and scalability becomes an important point it will be hard to extract some features to make those scaleable. Also it's easy to work at such projects as long as there are a few developers working on it or optimally one. With more people working on a such project more conflicts will occure.

**Pros:**
- Simplicity: Easy to understand and implement quickly
- Familiarity: Most developers know this pattern
- Fast initial development: Less boilerplate, get productive immediately
- Clear separation: Each layer has obvious responsibilities
- Tooling support: Works naturally with EF Core and ASP.NET patterns
- Easy onboarding: New contributors can start quickly

**Cons:**
- Tight coupling: Layers depend on concrete implementations below
- Testing challenges: Hard to test business logic without database
- Less flexible: Difficult to swap out data access layer
- Anemic domain: Business logic often scattered across services
- Layer violations: Easy to accidentally create dependencies across layers
- Scalability limits: Can become monolithic and hard to split

**Trade-offs:**
- Development speed vs. architectural purity
- Pragmatism vs. testability
- Immediate productivity vs. long-term flexibility

---

### Option 2: Clean Architecture / Onion

**Description:**

Dependency inversion-based architecture where the domain core is isolated 
from external concerns. Dependencies point inward toward the domain, never 
outward. External systems (database, APIs, UI) depend on the core, not 
vice versa.

**Structure:**
- **Domain Core**: Entities, value objects, domain interfaces (no dependencies)
- **Application Layer**: Use cases, business logic, application services
- **Infrastructure**: Database access, external APIs, file system
- **Presentation**: API controllers, middleware, configuration

**Pros:**
- Testability: Core business logic can be tested without external dependencies
- Maintainability: Clear separation of concerns, easy to locate code
- Flexibility: Easy to swap infrastructure (e.g., change database)
- Framework independence: Domain logic doesn't depend on .NET specifics
- Professional appearance: Demonstrates architectural maturity for contributors
- Scalability: Structure scales well as project grows

**Cons:**
- Boilerplate overhead: More files, interfaces, and mapping code
- Steeper learning curve: Contributors need to understand the pattern
- Slower initial development: More upfront setup required
- Can be overkill: For simple CRUD operations, adds unnecessary complexity
- Requires discipline: Easy to violate boundaries without strict reviews

**Trade-offs:**
- Code organization vs. development speed
- Testability vs. simplicity
- Long-term maintainability vs. short-term productivity
  
---

### Option 3: Command Query Responsibility Segregation 

**Description:**
[Description]

**Pros:**
- 
- 

**Cons:**
- 
- 


### Option 4: Hybrid - Clean-ish Layered

**Description:**
[Description]

**Pros:**
- 
- 

**Cons:**
- 
- 

---

## Rationale

[Explain why this option was chosen]

## Consequences

### Positive
- 

### Negative
- 

### Neutral
- 

## Implementation Notes

[Optional - How to implement this decision]

## References

[Optional - Links to relevant documentation or resources]
