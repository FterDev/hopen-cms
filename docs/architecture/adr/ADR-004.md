# ADR-004: Technology Stack and Project Structure

**Status:** Accepted  
**Date:** 2026-01-25
**Author:** Fedor Terekhov (FterDev)

## Context

Hopen requires clear decisions on technology choices and project structure to 
establish a consistent development approach. These decisions impact development 
speed, maintainability, contributor onboarding, and long-term scalability.

**Technology Commitments:**

Based on project goals and requirements, we have committed to:
- **Backend:** .NET 10 (latest stable release)
- **Frontend:** Angular 21 (latest stable release)
- **Database:** PostgreSQL with Entity Framework Core
- **Containerization:** Docker & Docker Compose

However, within these frameworks, multiple architectural approaches exist that 
require explicit decisions.

**Key Questions to Answer:**

**Backend (.NET 10):**
1. API Style: Minimal APIs vs Traditional Controllers?
2. Project Structure: How to organize Core, Application, Infrastructure, API layers?
3. ORM Approach: Code-first vs Database-first? How to handle migrations?
4. Repository Pattern: Use it or access DbContext directly?

**Frontend (Angular 21):**
1. Component Architecture: Standalone components only or mix with NgModules?
2. State Management: Signals (new) vs RxJS observables (traditional)?
3. Project Structure: How to organize Pages, Features, Shared, Core?
4. Routing: Where to define routes?

**Why These Decisions Matter:**

**Development Speed:**
- Minimal APIs are faster to scaffold but less structured than Controllers
- Standalone components reduce boilerplate but may be unfamiliar to contributors
- Signals simplify state management but are newer with less community resources

**Maintainability:**
- Controllers provide better organization for large applications
- Clear project structure determines how easily contributors can locate code
- Consistent patterns reduce cognitive load

**Team & Contributors:**
- Hopen starts as a solo project but is designed for open source contribution
- Contributors may have varying familiarity with latest features
- Documentation burden increases with non-standard patterns

**Constraints:**

- MVP needs to ship quickly (favor speed over perfection)
- Open source from day one (favor approachability)
- Solo development initially (favor productivity)
- Must scale as project and contributor base grows

---

## Decision

We will use a **modern, structured approach** leveraging the latest features of 
.NET 10 and Angular 21 while maintaining clear architectural boundaries.

### Backend Architecture (.NET 10)

**API Style: Traditional Controllers**

We will use ASP.NET Core Controllers with attribute routing instead of Minimal APIs.

```csharp
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0")]
public class ContentTypesController : HopenControllerBase
{
    private readonly IContentTypeService _service;
    
    [HttpPost]
    [Authorize(Roles = "Admin")]
    public async Task<IActionResult> Create(CreateContentTypeDto dto)
    {
        var result = await _service.CreateAsync(dto);
        return Created(result);
    }
}
```

**Project Structure: Feature-Oriented with Clear Layers**

```
Hopen.Core/                     # Domain entities, interfaces
  Entities/
    ContentType.cs
    Content.cs
  Interfaces/
    IContentTypeRepository.cs
  
Hopen.Application/              # Business logic, use cases
  Features/
    ContentTypes/
      Services/
        ContentTypeService.cs
      DTOs/
        CreateContentTypeDto.cs
      Validators/
        ContentTypeValidator.cs
        
Hopen.Infrastructure/           # External concerns
  Data/
    HopenDbContext.cs
    Repositories/
      ContentTypeRepository.cs
  External/
    EmailService.cs
    
Hopen.Api/                      # Presentation layer
  Controllers/
    HopenControllerBase.cs
    ContentTypesController.cs
  Middleware/
  Configuration/
  Program.cs
```

**ORM Strategy: Code-First with Entity Framework Core**

```csharp
public class HopenDbContext : DbContext
{
    public DbSet<ContentType> ContentTypes { get; set; }
    public DbSet<Content> Content { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<ContentType>(entity =>
        {
            entity.Property(e => e.Schema).HasColumnType("jsonb");
        });
    }
}

// Migrations tracked in Git
dotnet ef migrations add InitialCreate
dotnet ef database update
```

**Repository Pattern: Yes**

```csharp
public interface IContentTypeRepository
{
    Task<ContentType?> GetByIdAsync(Guid id);
    Task<List<ContentType>> GetAllAsync();
    Task<ContentType> CreateAsync(ContentType entity);
    Task UpdateAsync(ContentType entity);
    Task DeleteAsync(Guid id);
    IQueryable<ContentType> Query();  // For complex queries
}
```

**Base Controller for Shared Functionality**

```csharp
public abstract class HopenControllerBase : ControllerBase
{
    protected IActionResult Created<T>(T resource)
    {
        // Consistent Created responses
        return StatusCode(201, resource);
    }
    
    protected Guid CurrentUserId => 
        Guid.Parse(User.FindFirst(ClaimTypes.NameIdentifier)?.Value 
            ?? throw new UnauthorizedException());
}
```

---

### Frontend Architecture (Angular 21)

**Component Architecture: Pure Standalone Components**

```typescript
// No NgModules!
@Component({
  selector: 'app-content-types-list',
  standalone: true,
  imports: [CommonModule, MatTableModule, RouterLink],
  templateUrl: './content-types-list.page.html'
})
export class ContentTypesListPage {
  contentTypes = signal<ContentType[]>([]);
}
```

**State Management: Signals with RxJS for Complex Async**

```typescript
export class ContentTypesListPage {
  // Signals for component state
  contentTypes = signal<ContentType[]>([]);
  loading = signal(false);
  
  // Computed state
  publishedCount = computed(() => 
    this.contentTypes().filter(ct => ct.isActive).length
  );
  
  // RxJS for complex async operations
  searchTerm$ = new Subject<string>();
  
  constructor(private service: ContentTypeService) {
    // RxJS for debounced search
    this.searchTerm$.pipe(
      debounceTime(300),
      distinctUntilChanged(),
      switchMap(term => this.service.search(term))
    ).subscribe(results => {
      this.contentTypes.set(results); // Update signal
    });
  }
}
```

**Project Structure: Layered with Clear Responsibilities**

```
src/app/
  pages/                        # Presentation layer (routing, orchestration)
    content-types/
      list/
        content-types-list.page.ts
      edit/
        content-types-edit.page.ts
      content-types.routes.ts   # Routes defined here
    content/
      list/
      edit/
      content.routes.ts
      
  features/                     # Business logic layer
    content-types/
      services/
        content-type.service.ts
      models/
        content-type.model.ts
      components/               # Feature-specific presentational components
        content-type-form.component.ts
        content-type-card.component.ts
      validators/
        
  shared/                       # Generic reusable components/services
    components/
      data-table/
      modal/
      form-field/
    services/
      api.service.ts
      notification.service.ts
    pipes/
    directives/
    utils/
    
  core/                         # App-wide singletons and infrastructure
    auth/
      services/
        auth.service.ts
      guards/
        auth.guard.ts
      interceptors/
        auth.interceptor.ts
    layout/
      header.component.ts
      sidebar.component.ts
    config/
      app.config.ts
```

**Import Rules:**
```
Pages → Features, Shared, Core    ✅ Allowed
Features → Shared, Core            ✅ Allowed
Features → Pages                   ❌ Forbidden
Shared → Features, Pages           ❌ Forbidden
Shared → Core                      ✅ Allowed (auth state, config)
```

**Routing Configuration**

```typescript
// pages/content-types/content-types.routes.ts
export const contentTypesRoutes: Routes = [
  {
    path: 'content-types',
    children: [
      {
        path: '',
        component: ContentTypesListPage
      },
      {
        path: 'new',
        component: ContentTypesEditPage
      },
      {
        path: ':id',
        component: ContentTypesEditPage
      }
    ]
  }
];

// app.routes.ts (root)
import { contentTypesRoutes } from './pages/content-types/content-types.routes';

export const routes: Routes = [
  ...contentTypesRoutes,
  ...contentRoutes,
  // ...
];
```

---

## Rationale

### Backend Decisions

**Controllers over Minimal APIs:**

**Structure and organization:**
At scale, Hopen will have 25+ endpoints across multiple resources (ContentTypes, 
Content, Auth, Media, Webhooks). Controllers provide natural organization by 
grouping related endpoints together, preventing Program.cs from becoming a 
500-line file.

**Attribute-based configuration:**
Controllers excel at cross-cutting concerns through attributes (`[Authorize]`, 
`[ValidateModel]`, `[ApiVersion]`). These are more readable and maintainable 
than Minimal API's fluent configuration chains. Custom attributes can be added 
easily for future requirements (audit logging, rate limiting, etc.).

**Contributor friendliness:**
Controllers are the established pattern in ASP.NET Core. New contributors can 
immediately understand where to add endpoints and how to apply common patterns. 
The convention-based approach reduces documentation burden.

**Testing approach:**
While we will use integration tests through HTTP (closest to reality, enables 
load testing), Controllers can also be unit tested directly when needed. This 
flexibility is valuable for complex authorization logic or edge cases.

**Trade-off accepted:**
We sacrifice minimal performance gains (~5-10ms per request) for superior 
organization, maintainability, and contributor experience. For a CMS application, 
this trade-off strongly favors structure over marginal performance.

---

**Feature-oriented project structure:**

Organizing code by feature (ContentTypes, Content, Auth) rather than by technical 
layer creates clear boundaries. Each feature is self-contained with its services, 
DTOs, and validators together. This aligns with our hybrid Clean Architecture 
approach from ADR-001 and makes it obvious where new functionality belongs.

---

**Code-first Entity Framework:**

**Testability:**
Code-first enables Testcontainers for integration testing. We can spin up real 
PostgreSQL instances in CI/CD, run migrations, and test against actual database 
behavior. This is far superior to mocking DbContext.

**Version control:**
Migrations are C# files tracked in Git, providing full history of schema changes. 
Rollback is straightforward, and conflicts are visible in code review.

**CI/CD integration:**
`dotnet ef database update` runs in deployment pipelines. No manual SQL scripts 
to execute or coordinate. Database state is deterministic from code.

**PostgreSQL features:**
While code-first is our foundation, we're not dogmatic. Complex PostgreSQL-specific 
features (advanced indexes, generated columns) can be added via raw SQL in 
migrations when needed. The 80/20 rule applies: code-first handles most cases, 
custom SQL for optimization.

---

**Repository Pattern:**

Aligns with our Clean Architecture approach. Core domain logic doesn't depend 
on EF Core directly. Repositories provide a clear abstraction for data access, 
making business logic more testable and the architecture more flexible.

**Pragmatic approach:**
- Simple CRUD: Repository provides standard methods
- Complex queries: `IQueryable<T> Query()` method exposes flexibility
- Special cases: Custom methods added case-by-case

This avoids both extremes: not every operation needs a dedicated repository 
method, but we maintain architectural boundaries where they matter.

---

**Base Controller:**

Eliminates duplication across controllers. Common patterns (Created responses, 
CurrentUserId extraction, validation error formatting) are centralized. When we 
add new cross-cutting concerns (e.g., tenant context, request correlation IDs), 
we add them once in the base controller.

---

### Frontend Decisions

**Pure Standalone Components:**

Angular 21's recommended approach. Standalone components are the future of Angular. 
Starting with them from day one means:
- No technical debt from NgModules to migrate later
- Smaller bundle sizes (tree-shakeable by default)
- Less boilerplate (no module declarations)
- Simpler mental model for contributors learning Angular

**Trade-off accepted:**
Some contributors may only know NgModules, but Angular's documentation now 
defaults to standalone. Contributors will learn the modern approach, not legacy 
patterns.

---

**Signals with RxJS:**

**Signals for state:**
Simpler mental model than RxJS for component state. No subscriptions to manage, 
no memory leaks from forgotten unsubscribe. Computed signals provide reactive 
derived state without complex pipe operators.

**RxJS for complex async:**
HTTP requests return Observables. Complex operations (debounced search, retry 
logic, combined API calls) benefit from RxJS operators. We don't force everything 
into one paradigm.

**Best of both worlds:**
Use Signals for what they excel at (simple reactive state) and RxJS where it 
shines (async pipelines). Bridge them by updating Signals from RxJS subscriptions. 
This pragmatic approach leverages Angular 21's modern capabilities without 
abandoning proven patterns.

---

**Layered project structure (Pages/Features/Shared/Core):**

**Clear separation of concerns:**

**Pages layer:**
Presentation and routing only. Pages are thin orchestrators that compose feature 
components and services. They know about URLs, navigation, and high-level layout, 
but contain no business logic.

**Features layer:**
Business logic, domain services, and feature-specific components. This is where 
ContentType creation logic, validation rules, and API integration live. Features 
are self-contained and reusable.

**Shared layer:**
Generic, reusable components and services with no domain knowledge. A DataTable 
component doesn't know about ContentTypes - it's purely presentational. This 
layer grows slowly and deliberately.

**Core layer:**
App-wide infrastructure. Authentication, authorization, global layout, 
configuration. These are singletons that every part of the app may depend on.

**Enforcement through imports:**
The structure isn't just convention - it's enforceable. Features cannot import 
Pages. Shared cannot import Features. This prevents circular dependencies and 
ensures proper layering. ESLint rules can enforce these boundaries in CI/CD.

**Contributor clarity:**
- Want to add a new page? → pages/
- Want to add business logic? → features/
- Want to add a reusable component? → shared/
- Want to modify authentication? → core/

No ambiguity about where code belongs.

---

**Routing at Pages layer:**

Routes are defined where they're used - in the Pages layer. Each page feature 
directory contains its routes file, making it obvious what URLs that page 
responds to. The root app.routes.ts simply imports and composes all feature 
routes. This keeps routing concerns close to presentation concerns.

---

## Consequences

### Positive

**Backend:**
- Clear structure prevents chaotic growth as codebase scales
- Controllers group related endpoints logically
- Feature-oriented folders make new features easy to add
- Base controller eliminates cross-cutting concern duplication
- Code-first EF enables Testcontainers and deterministic deployments
- Repository pattern maintains Clean Architecture boundaries
- Custom attributes extensibility for future needs (audit, rate limiting)

**Frontend:**
- Standalone components align with Angular's future direction
- Signals simplify state management and improve performance
- Layered structure with enforced boundaries prevents architecture drift
- Pages/Features separation makes large-scale refactoring manageable
- Shared components are truly reusable (no domain coupling)
- Core infrastructure is centralized and easy to modify
- Import rules prevent circular dependencies

**Cross-cutting:**
- Consistent patterns across backend and frontend (feature-oriented)
- Modern tech stack attracts contributors familiar with latest practices
- Portfolio demonstrates understanding of current best practices
- Architecture scales from MVP to production without major rewrites

### Negative

**Backend:**
- More files and directories than Minimal API approach
- Repository pattern adds abstraction layer (some view as unnecessary)
- Controllers require more boilerplate than Minimal APIs
- Custom attributes require understanding of ASP.NET Core filters
- Code-first migrations can become complex for advanced PostgreSQL features

**Frontend:**
- Some contributors may only know NgModules and need to learn standalone
- Signals are newer, less Stack Overflow content than RxJS
- Four-layer structure (Pages/Features/Shared/Core) requires initial learning
- Import rules must be documented and potentially enforced with linting
- Mixing Signals and RxJS requires understanding both paradigms

**Cross-cutting:**
- Modern tech choices mean bleeding-edge issues may arise
- Documentation burden higher than using "default" patterns
- Some established developers may prefer traditional approaches

### Neutral

- Controllers vs Minimal APIs performance difference is negligible for CMS use case
- Repository pattern debate is ongoing in .NET community - we choose structure
- Signals vs pure RxJS will evolve as Angular matures
- Project structure can be refactored later if patterns don't scale as expected
- Custom attribute usage will be decided on case-by-case basis

---

## Implementation Notes

**Backend Setup:**

1. Solution structure: 4 projects (Core, Application, Infrastructure, Api)
2. Project dependencies: Core → Application → Infrastructure → Api
3. Key packages: 
   - Npgsql.EntityFrameworkCore.PostgreSQL
   - Microsoft.EntityFrameworkCore.Design
   - Swashbuckle.AspNetCore
   - Asp.Versioning.Mvc
4. EF Core migrations tracked in Git, applied via `dotnet ef database update`
5. Services registered with dependency injection in startup

**Frontend Setup:**

1. Angular 21 project with standalone components and routing
2. Directory structure: pages/, features/, shared/, core/
3. Key packages: @angular/material, RxJS
4. Routes defined in pages/ directories, imported in root app.routes.ts
5. Base API service in shared/services/ for HTTP communication

**Testing Strategy:**

- Backend: Integration tests with Testcontainers for real PostgreSQL instances
- Frontend: Component tests with TestBed and mocked services
- Controllers tested via HTTP for realistic behavior
- See `/tests` directory for reference implementations

---

## References

**Backend:**
- [ASP.NET Core Controllers](https://learn.microsoft.com/en-us/aspnet/core/web-api/)
- [Entity Framework Core](https://learn.microsoft.com/en-us/ef/core/)
- [Repository Pattern in .NET](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-design)
- [Testcontainers for .NET](https://dotnet.testcontainers.org/)

**Frontend:**
- [Angular Standalone Components](https://angular.dev/guide/components/importing)
- [Angular Signals](https://angular.dev/guide/signals)
- [Angular Architecture Guide](https://angular.dev/guide/architecture)
- [RxJS Documentation](https://rxjs.dev/)

**Architecture:**
- [Clean Architecture by Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Feature-Oriented Project Structure](https://angular.dev/style-guide#overall-structural-guidelines)