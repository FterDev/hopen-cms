# ADR-002: API Design

**Status:** Accepted  
**Date:** 2026-01-25 
**Author:** Fedor Terekhov (FterDev)

## Context

We need to establish consistent API design principles for Hopen's REST API to ensure:
- Clear versioning strategy for backward compatibility
- Predictable endpoint structure for API consumers
- Standardized error handling across all endpoints
- Consistent request/response formats

## Decision

We will use URL path versioning with RESTful conventions and standardized error handling.

**API Versioning:**
- URL path versioning: `/api/v1/...`
- Major version only in URL (breaking changes increment version)

**RESTful Conventions:**
Standard CRUD operations follow REST principles:
```
GET    /api/v1/content-types           # List all content types
GET    /api/v1/content-types/{id}      # Get single content type
POST   /api/v1/content-types           # Create new content type
PUT    /api/v1/content-types/{id}      # Update content type
DELETE /api/v1/content-types/{id}      # Delete content type

GET    /api/v1/content                 # List all content
GET    /api/v1/content/{id}            # Get single content item
POST   /api/v1/content                 # Create new content
PUT    /api/v1/content/{id}            # Update content
DELETE /api/v1/content/{id}            # Delete content
```

**Special Operations:**
Non-CRUD operations receive dedicated URL segments:
```
PATCH  /api/v1/content/{id}/publish    # Publish content
PATCH  /api/v1/content/{id}/unpublish  # Unpublish content
POST   /api/v1/content/{id}/duplicate  # Duplicate content
GET    /api/v1/content-types/{id}/content  # Get all content for a type
```

**Request/Response Format:**
- All requests and responses use JSON
- Content-Type: `application/json`
- Accept: `application/json`

**Error Handling:**
Global error handler middleware converts exceptions to appropriate HTTP status codes:

Known errors:
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Content type name is required",
    "details": [
      {
        "field": "name",
        "message": "Name cannot be empty"
      }
    ]
  }
}
```

Status code mapping:
- `400 Bad Request` - Validation errors, malformed requests
- `401 Unauthorized` - Missing or invalid authentication
- `403 Forbidden` - Authenticated but insufficient permissions
- `404 Not Found` - Resource does not exist
- `409 Conflict` - Duplicate resource, constraint violations
- `500 Internal Server Error` - Unknown/unhandled exceptions

Unknown errors:
```json
{
  "error": {
    "code": "INTERNAL_ERROR",
    "message": "An unexpected error occurred",
    "requestId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
  }
}
```

Note: Stack traces excluded in production for security.

---

## Rationale

**URL versioning chosen because:**
- Explicit and discoverable - version visible in every request
- Easy to test - can curl different versions directly
- Browser-friendly - works in browser address bar
- Standard practice - most REST APIs use this approach
- ASP.NET Core native support via attribute routing

**RESTful conventions provide:**
- Predictable API structure for consumers
- Industry standard - developers know what to expect
- Self-documenting - HTTP methods indicate operation type

**Special operation endpoints:**
- Actions that don't fit CRUD need explicit naming
- `/publish`, `/duplicate` clearly communicate intent
- Avoids overloading PUT/PATCH with complex behavior

**Global error handler ensures:**
- Consistent error format across all endpoints
- Security - no stack traces or internal details leaked
- Debugging support via requestId for server logs
- Client-friendly error messages

## Consequences

### Positive

- API consumers can easily understand and predict endpoint behavior
- Version changes are explicit and non-breaking for older clients
- Consistent error handling reduces client-side error parsing complexity
- JSON format is universally supported and human-readable
- RESTful conventions make API self-documenting
- Global error handler centralizes error logic (DRY principle)

### Negative

- URL changes when major version increments (v1 â†’ v2)
- Must maintain multiple API versions simultaneously during transition
- Special operation endpoints add more routes to maintain
- Global error handler must catch all exception types correctly
- JSON-only format excludes other formats (XML, protobuf)

### Neutral

- Versioning strategy is a one-time decision, rarely changes
- Error format may need adjustments based on client feedback
- Special operations may accumulate over time, requiring documentation
- RequestId correlation requires logging infrastructure

## Implementation Notes

**ASP.NET Core Setup:**

1. Configure API versioning in `Program.cs`:
```csharp
builder.Services.AddApiVersioning(options =>
{
    options.DefaultApiVersion = new ApiVersion(1, 0);
    options.AssumeDefaultVersionWhenUnspecified = true;
    options.ReportApiVersions = true;
});
```

2. Version controllers with attributes:
```csharp
[ApiController]
[Route("api/v{version:apiVersion}/[controller]")]
[ApiVersion("1.0")]
public class ContentTypesController : ControllerBase
{
    // ...
}
```

3. Global error handler middleware:
```csharp
app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        var exception = context.Features.Get<IExceptionHandlerFeature>();
        var statusCode = exception.Error switch
        {
            ValidationException => 400,
            UnauthorizedException => 401,
            ForbiddenException => 403,
            NotFoundException => 404,
            ConflictException => 409,
            _ => 500
        };
        
        await context.Response.WriteAsJsonAsync(new ErrorResponse
        {
            Error = new ErrorDetail
            {
                Code = GetErrorCode(exception.Error),
                Message = exception.Error.Message,
                RequestId = context.TraceIdentifier
            }
        });
    });
});
```

4. Custom exception types:
```csharp
public class ValidationException : Exception { }
public class NotFoundException : Exception { }
// etc.
```

**Testing:**
- Integration tests for each HTTP status code scenario
- Verify error response format matches specification
- Test version routing with v1, v2 (future)

## References

- [Microsoft REST API Guidelines](https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)
- [ASP.NET Core API Versioning](https://github.com/dotnet/aspnet-api-versioning)
- [RFC 7807 - Problem Details for HTTP APIs](https://datatracker.ietf.org/doc/html/rfc7807)
- [RESTful Web Services](https://restfulapi.net/)